<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÎèôÍ∑∏ÎùºÎØ∏ Ïà´Ïûê ÎπàÎèÑ Î∂ÑÏÑùÍ∏∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            background: linear-gradient(135deg, #EFF6FF 0%, #E0E7FF 100%);
            min-height: 100vh;
            padding: 0.5rem;
        }

        @media (min-width: 640px) {
            body {
                padding: 1rem;
            }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            font-size: 1.25rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 0.75rem;
            color: #3730A3;
        }

        @media (min-width: 640px) {
            h1 {
                font-size: 1.875rem;
            }
        }

        .input-section {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 0.75rem;
            margin-bottom: 0.75rem;
        }

        label {
            display: block;
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #374151;
        }

        .hint {
            font-size: 0.75rem;
            color: #4B5563;
            margin-bottom: 0.5rem;
            line-height: 1.5;
        }

        textarea {
            width: 100%;
            height: 10rem;
            padding: 0.75rem;
            border: 2px solid #D1D5DB;
            border-radius: 0.5rem;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            resize: vertical;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #6366F1;
        }

        button {
            margin-top: 0.75rem;
            width: 100%;
            background: #6366F1;
            color: white;
            font-weight: bold;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            border: none;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #4F46E5;
        }

        button:active {
            background: #4338CA;
        }

        .analysis-box {
            background: linear-gradient(135deg, #F5F3FF 0%, #EFF6FF 100%);
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            margin-bottom: 0.75rem;
            
        }

        .analysis-title {
            font-size: 1.125rem;
            font-weight: bold;
            margin-bottom: 0.75rem;
            color: #1F2937;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .card {
            background: white;
            border-radius: 0.5rem;
            padding: 0.75rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .card-label {
            font-size: 0.75rem;
            color: #4B5563;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .number-display {
            display: flex;
            justify-content: center;
            gap: 0.25rem;
            font-size: 1.5rem;
            margin: 0.5rem 0;
        }

        .number-display span {
            font-size: 1.875rem;
        }

        .dividend-value {
            font-size: 1.25rem;
            font-weight: bold;
            color: #1F2937;
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
        }

        .proportion-value {
            font-size: 1.125rem;
            font-weight: bold;
            color: #059669;
            margin-top: 0.25rem;
        }

        .ratio-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
        }

        .ratio-box {
            border-radius: 0.5rem;
            padding: 0.75rem;
            
        }

        .ratio-box.yellow {
            background: #FEF3C7;
            border-color: #FDE68A;
        }

        .ratio-label {
            font-size: 0.75rem;
            margin-bottom: 0.25rem;
            font-weight: 600;
        }

        .ratio-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        .ratio-formula {
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }

        .total-ratio-box {
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 1rem;
            margin-bottom: 0.75rem;
            border: 2px solid #E5E7EB;
        }

        .total-ratio-title {
            font-size: 1.125rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: black;
        }

        .total-ratio-value {
            font-size: 1.875rem;
            font-weight: bold;
            color: black;
        }

        .total-ratio-formula {
            font-size: 0.875rem;
            color: black;
            margin-top: 0.25rem;
        }

        .info-box {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            padding: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .info-title {
            font-size: 0.875rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #374151;
        }

        .gradient-bar {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
        }

        .gradient-box {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .color-sample {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 0.25rem;
        }

        .gradient-fill {
            flex: 1;
            height: 1.25rem;
            border-radius: 0.25rem;
            background: linear-gradient(to right, rgb(96, 165, 250), rgb(255, 255, 255), rgb(239, 68, 68));
        }

        .info-text {
            font-size: 0.75rem;
            color: #4B5563;
            margin-top: 0.5rem;
        }

        .table-container {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
            margin-bottom: 1rem;
        }

        .table-title {
            font-size: 1rem;
            font-weight: bold;
            padding: 0.75rem;
            background: #F9FAFB;
            border-bottom: 1px solid #E5E7EB;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
            table-layout: fixed;
        }

        th, td {
            border: 1px solid #D1D5DB;
            padding: 0.5rem;
            text-align: center;
        }

        th {
            background: #F3F4F6;
            font-weight: bold;
            font-size: 0.875rem;
        }

        th.orange-bg {
            background: #FED7AA;
        }

        td.yellow-bg {
            background: #FDE047;
            font-size: 1.5rem;
        }

        td.orange-bg {
            background: #FEF3C7;
        }

        td.value-cell {
            font-weight: bold;
            font-size: 1rem;
        }
    

        /* ========== index2222 Ïä§ÌÉÄÏùº ========== */

        /* ÌÖåÏù¥Î∏î Ìó§Îçî ÏÉâÏÉÅ Î™ÖÏãúÏ†Å Ï†ÅÏö© */
        #results2 .data-table thead {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%) !important;
            color: white !important;
        }

        #results2 .data-table thead.red {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%) !important;
            color: white !important;
        }

        #results2 .data-table thead.blue {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%) !important;
            color: white !important;
        }

        #results2 .data-table thead th {
            color: white !important;
            font-weight: 600 !important;
            background: transparent !important;
        }
        
        /* ÌÖåÏù¥Î∏î ÏùºÎ∞ò ÏÖÄ */
        #results2 .data-table td {
            color: #555 !important;
            background: white !important;
        }

        /* Î™®Î∞îÏùº Î∞òÏùëÌòï Ï°∞Ï†ï */
        @media (max-width: 768px) {
        * {
            box-sizing: border-box;
        }
        
        body {
            padding: 0.25rem !important;
        }
        
        .container {
            padding: 0 !important;
            margin: 0 auto;
        }
        
        .idx2-container {
            padding: 0 !important;
        }
        
        /* ÍµêÏ∞®Ï†êÎ∂ÑÏÑù Î∞ïÏä§ */
        .analysis-box {
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            box-sizing: border-box;
        }
        
        /* Ïπ¥Îìú Í∑∏Î¶¨Îìú - Í∞ÑÍ≤© ÏµúÏÜåÌôî */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.3rem;
            margin-bottom: 0.5rem;
            width: 100%;
            box-sizing: border-box;
        }
        
        /* Ïπ¥Îìú */
        .card {
            padding: 0.5rem;
            box-sizing: border-box;
            min-width: 0;
            overflow: hidden;
        }
        
        /* ÎèôÍ∑∏ÎùºÎØ∏ ÌÅ¨Í∏∞ Ïú†ÏßÄ */
        .number-display {
            margin: 0.25rem 0;
        }
        
        .number-display span {
            font-size: 1.875rem;
        }
        
        .card-label {
            font-size: 0.7rem;
            margin-bottom: 0.25rem;
        }
        
        .dividend-value {
            font-size: 1.1rem;
            padding: 0.2rem 0.5rem;
        }
        
        .proportion-value {
            font-size: 1rem;
            margin-top: 0.2rem;
        }
        
        /* ÎπÑÏú® Î∞ïÏä§ */
        .ratio-grid {
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }
        
        .ratio-box {
            padding: 0.5rem;
        }
        
        .ratio-label {
            font-size: 0.7rem;
        }
        
        .ratio-value {
            font-size: 1rem;
        }
        
        .ratio-formula {
            font-size: 0.65rem;
        }
        
        /* ÌîåÎ°úÌåÖ Î≤ÑÌäº - ÏúÑÏπò Ï°∞Ï†ï */
        
        
        .floating-buttons {
            position: fixed;
            bottom: 0.75rem;
            left: 0;
            right: 0;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            z-index: 1000;
        }
        
        .float-btn {
            width: 2.5rem;
            height: 2.5rem;
            font-size: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        /* ===== Î∞∞ÎãπÏú® ÏÉÅÏÑ∏ Î∂ÑÏÑù (results2Ïùò tableÎßå) ===== */
        
        /* results2 ÎÇ¥Î∂ÄÏùò Î™®Îì† table */
        #results2 table {
            width: 100% !important;
            table-layout: fixed !important;
            border-collapse: collapse !important;
            margin: 0 !important;
        }
        
        #results2 thead,
        #results2 tbody {
            width: 100% !important;
        }
        
        #results2 th,
        #results2 td {
            padding: 0.35rem 0.1rem !important;
            font-size: 0.7rem !important;
            box-sizing: border-box !important;
            word-wrap: break-word !important;
        }
        
        /* idx2-container ÏûêÏ≤¥ÎèÑ Ï†ÑÏ≤¥ Ìè≠ */
        .idx2-container {
            padding: 0.25rem !important;
            margin: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
            box-sizing: border-box !important;
        }
        
        
        /* Î∞∞ÎãπÏú® Î∂ÑÏÑù ÏÑπÏÖòÏùò Ìù∞ÏÉâ Î∞ïÏä§Îì§ */
        #results2 .number-section {
            padding: 0.5rem 0.25rem !important;
            margin-bottom: 0.75rem !important;
        }
        
        #results2 .number-header {
            padding: 0.5rem !important;
            margin-bottom: 0.5rem !important;
        }
        
        #results2 .table-wrapper {
            padding: 0 !important;
            margin: 0 !important;
        }
        
        #results2 {
            width: 100% !important;
            padding: 0 !important;
            margin: 0 !important;
        }

    }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow-x: hidden;
            width: 100%;
            position: relative;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #1e88e5 0%, #00acc1 100%);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            width: 100%;
            max-width: 100vw;
            position: relative;
        }

        .idx2-container {
            padding: 1rem !important;
            margin: 0 !important;
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            overflow-x: hidden;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 28px;
        }

        .input-section {
            margin-bottom: 30px;
        }

        .input-section label {
            display: block;
            font-size: 16px;
            font-weight: 600;
            color: #555;
            margin-bottom: 10px;
        }

        textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            transition: border-color 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .analyze-btn {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
        }

        .analyze-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 107, 53, 0.3);
        }

        .clear-btn {
            background: #e0e0e0;
            color: #555;
        }

        .clear-btn:hover {
            background: #d0d0d0;
        }

        .save-status {
            margin-top: 20px;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 10px;
            border-left: 5px solid #2196f3;
        }

        .save-status-text {
            font-size: 16px;
            color: #1565c0;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .save-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .excel-btn {
            flex: 1;
            background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .excel-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }

        .delete-all-btn {
            flex: 1;
            background: #f44336;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .delete-all-btn:hover {
            background: #d32f2f;
        }

        .results {
            margin-top: 30px;
        }

        .number-section {
            margin-bottom: 30px;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            border-left: 5px solid #667eea;
        }

        .number-section.summary {
            border-left-color: #e74c3c;
        }

        .number-section.crosspoint {
            border-left-color: #3498db;
            background: #ebf5fb;
        }

        .number-header {
            font-size: 20px;
            font-weight: 700;
            color: #333;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .number-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            border-radius: 50%;
            font-size: 18px;
            font-weight: 700;
        }

        .number-badge.red {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .number-badge.blue {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            table-layout: fixed;
        }

        .table-wrapper {
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            width: 100%;
            max-width: 100%;
        }

        .data-table thead {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
        }

        .data-table thead.red {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .data-table thead.blue {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }

        .data-table th,
        .data-table td {
            padding: 12px 8px;
            text-align: center;
            border-bottom: 1px solid #eee;
            font-size: 13px;
        }

        .data-table th {
            font-weight: 600;
            font-size: 12px;
        }

        .data-table td {
            color: #555;
        }

        .data-table tbody tr:hover {
            background: #f0f0f0;
        }

        .data-table tbody tr:last-child td {
            border-bottom: none;
        }

        .pair-cell {
            font-weight: 600;
            color: #ff6b35;
            font-size: 14px;
        }

        .odds-cell {
            font-weight: 700;
            color: #e74c3c;
            font-size: 14px;
        }

        .ratio-cell {
            color: #27ae60;
            font-weight: 600;
        }

        .formula-cell {
            color: #e67e22;
            font-weight: 600;
            font-size: 11px;
        }

        .result-cell {
            color: #2980b9;
            font-weight: 700;
            font-size: 13px;
        }

        .summary {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 10px;
            border-left: 5px solid #ffc107;
        }

        .summary-text {
            font-size: 14px;
            color: #856404;
            font-weight: 600;
        }

        .chart-container {
            margin-top: 20px;
            padding: 20px;
            background: white;
            border-radius: 10px;
        }

        .chart-title {
            font-size: 16px;
            font-weight: 700;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
        }

        .chart-bar {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 10px;
        }

        .chart-label {
            width: 40px;
            font-weight: 600;
            color: #ff6b35;
            text-align: right;
            font-size: 14px;
        }

        .chart-bar-container {
            flex: 1;
            height: 24px;
            background: #f0f0f0;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }

        .chart-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b35 0%, #f7931e 100%);
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 8px;
        }

        .chart-value {
            color: white;
            font-size: 11px;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .crosspoint-title {
            font-size: 16px;
            font-weight: 700;
            color: #2980b9;
            margin-bottom: 15px;
            margin-top: 10px;
        }

        .no-data {
            text-align: center;
            padding: 40px;
            color: #999;
            font-size: 16px;
        }

        
    


        /* ÌîåÎ°úÌåÖ Î≤ÑÌäº Ïä§ÌÉÄÏùº */
        .floating-buttons {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row;
            gap: 0.75rem;
            z-index: 1000;
        }

        .float-btn {
            width: 3.5rem;
            height: 3.5rem;
            border-radius: 50%;
            background: linear-gradient(135deg, #6366F1 0%, #4F46E5 100%);
            color: white;
            border: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: all 0.3s;
        }

        .float-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
        }

        .float-btn:active {
            transform: translateY(0);
        }

        .float-btn.btn-a {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
        }
        
        .float-btn.btn-b {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
        }
        
        .float-btn.btn-c {
            background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
        }
        
        .float-btn.btn-d {
            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%);
        }

        @media (max-width: 640px) {
            .floating-buttons {
                right: 0.5rem;
                bottom: 0.5rem;
            }
            
            .float-btn {
                width: 3rem;
                height: 3rem;
                font-size: 1.25rem;
            }
        }
</style>
</head>
<body>
    <div class="container">
        <h1>üî¢ ÎèôÍ∑∏ÎùºÎØ∏ Ïà´Ïûê ÎπàÎèÑ Î∂ÑÏÑùÍ∏∞</h1>

        <div class="input-section">
            <label>Îç∞Ïù¥ÌÑ∞ ÏûÖÎ†• (ÏûêÏú† ÌòïÏãù)</label>
            <p class="hint">
                ÎèôÍ∑∏ÎùºÎØ∏ Ïà´Ïûê 6Í∞úÍ∞Ä 1Ï§ÑÏûÖÎãàÎã§. Ïà´ÏûêÎÇò Í≥µÎ∞±ÏùÄ Î¨¥ÏãúÎêòÎ©∞ ÎèôÍ∑∏ÎùºÎØ∏ Ïà´ÏûêÎßå Ï∂îÏ∂úÎê©ÎãàÎã§.<br/>
                Ïòà: ‚ë•‚ë™ 4.6 ‚ë•‚ë£ 6.8 ‚ë•‚ë¢ 7.3 (Ïù¥Î†áÍ≤å ÏûÖÎ†•Ìï¥ÎèÑ ÏûêÎèôÏúºÎ°ú ‚ë•‚ë™‚ë•‚ë£‚ë•‚ë¢Î°ú Ïù∏Ïãù)
            </p>
            <textarea id="inputData" placeholder="ÏòàÏãú:
‚ë•‚ë™ 4.6 ‚ë•‚ë£ 6.8 ‚ë•‚ë¢ 7.3
‚ë•‚ë§ 8.5 ‚ë™‚ë• 11.6 ‚ë•‚ë° 13.5"></textarea>
            <button onclick="analyzeData()">Î∂ÑÏÑùÌïòÍ∏∞</button>
        </div>

        <div id="results"></div>

        <!-- ========== index2222 ÏòÅÏó≠ ========== -->
        <div style="
            background: linear-gradient(135deg, #1e88e5 0%, #00acc1 100%);
            margin: 2rem 0 1.5rem 0;
            padding: 1rem;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 1.25rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        ">
            üìä Î∞∞ÎãπÏú® ÏÉÅÏÑ∏ Î∂ÑÏÑù
        </div>

        <div class="idx2-container">
            <div id="results2" class="results"></div>
        </div>


        <!-- ÌîåÎ°úÌåÖ Î≤ÑÌäº -->
        <div class="floating-buttons">
            <button class="float-btn btn-a" onclick="scrollToSectionA()" title="ÍµêÏ∞®Ï†êÎ∂ÑÏÑù1Î°ú Ïù¥Îèô">
                A
            </button>
            <button class="float-btn btn-b" onclick="scrollToSectionB()" title="1-10Ï§Ñ Î∂ÑÏÑùÏúºÎ°ú Ïù¥Îèô">
                B
            </button>
            <button class="float-btn btn-c" onclick="scrollToSectionC()" title="Ï†ÑÏ≤¥ Ïà´ÏûêÎ≥Ñ Î∞∞Îãπ Ìï©Í≥ÑÎ°ú Ïù¥Îèô">
                C
            </button>
            <button class="float-btn btn-d" onclick="scrollToSectionD()" title="Í∞Å Ïà´ÏûêÎ≥Ñ Ï≤´ Î≤àÏß∏ Ï°∞Ìï©ÏúºÎ°ú Ïù¥Îèô">
                D
            </button>
        </div>
    </div>

    <script>
        let results = null;
        let analysis1 = null;
        let additionalAnalyses = [];
        let analysis2 = null;
        let analysis3 = null;

        function extractNumbers(pair) {
            return pair.split('');
        }

        function analyzeData() {
            const inputData = document.getElementById('inputData').value;
            
            if (!inputData.trim()) {
                alert('Îç∞Ïù¥ÌÑ∞Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî!');
                return;
            }

            const circledNumbers = ['‚ë†', '‚ë°', '‚ë¢', '‚ë£', '‚ë§', '‚ë•', '‚ë¶', '‚ëß', '‚ë®', '‚ë©', '‚ë™', '‚ë´', '‚ë¨', '‚ë≠', '‚ëÆ', '‚ëØ'];
            
            const pairs = [];
            const dividends = [];
            
            const tokens = inputData.match(/[‚ë†‚ë°‚ë¢‚ë£‚ë§‚ë•‚ë¶‚ëß‚ë®‚ë©‚ë™‚ë´‚ë¨‚ë≠‚ëÆ‚ëØ]|[\d.]+/g) || [];
            
            for (let i = 0; i < tokens.length - 2; i++) {
                if (circledNumbers.includes(tokens[i]) && 
                    circledNumbers.includes(tokens[i + 1]) &&
                    !isNaN(parseFloat(tokens[i + 2]))) {
                    pairs.push(tokens[i] + tokens[i + 1]);
                    dividends.push(parseFloat(tokens[i + 2]));
                }
            }
            
            const sortedData = pairs.map((pair, idx) => ({
                pair: pair,
                dividend: dividends[idx]
            })).sort((a, b) => a.dividend - b.dividend);
            
            // ÍµêÏ∞®Ï†êÎ∂ÑÏÑù1
            let lowest1 = null;
            let lowest2 = null;
            let crossPoint1 = null;
            
            if (sortedData.length >= 2) {
                // Í≥µÌÜµ Ïà´ÏûêÍ∞Ä ÏûàÎäî ÏµúÏ†Ä 2Í∞ú Ïßù Ï∞æÍ∏∞
                for (let i = 0; i < sortedData.length; i++) {
                    for (let j = i + 1; j < sortedData.length; j++) {
                        const p1 = sortedData[i];
                        const p2 = sortedData[j];
                        
                        const num1_1 = p1.pair[0];
                        const num1_2 = p1.pair[1];
                        const num2_1 = p2.pair[0];
                        const num2_2 = p2.pair[1];
                        
                        let crossNum1, crossNum2;
                        let hasCommon = false;
                        
                        if (num1_1 === num2_1) {
                            crossNum1 = num1_2;
                            crossNum2 = num2_2;
                            hasCommon = true;
                        } else if (num1_1 === num2_2) {
                            crossNum1 = num1_2;
                            crossNum2 = num2_1;
                            hasCommon = true;
                        } else if (num1_2 === num2_1) {
                            crossNum1 = num1_1;
                            crossNum2 = num2_2;
                            hasCommon = true;
                        } else if (num1_2 === num2_2) {
                            crossNum1 = num1_1;
                            crossNum2 = num2_1;
                            hasCommon = true;
                        }
                        
                        if (hasCommon) {
                            const crossPair1_1 = crossNum1 + crossNum2;
                            const crossPair1_2 = crossNum2 + crossNum1;
                            
                            const crossIdx1 = pairs.indexOf(crossPair1_1);
                            const crossIdx2 = pairs.indexOf(crossPair1_2);
                            
                            if (crossIdx1 !== -1) {
                                lowest1 = p1;
                                lowest2 = p2;
                                crossPoint1 = {
                                    pair: crossPair1_1,
                                    dividend: dividends[crossIdx1]
                                };
                                break;
                            } else if (crossIdx2 !== -1) {
                                lowest1 = p1;
                                lowest2 = p2;
                                crossPoint1 = {
                                    pair: crossPair1_2,
                                    dividend: dividends[crossIdx2]
                                };
                                break;
                            }
                        }
                    }
                    if (lowest1 && lowest2 && crossPoint1) break;
                }
                
                if (crossPoint1) {
                    const sum1 = lowest1.dividend + lowest2.dividend + crossPoint1.dividend;
                    const ratio1 = ((lowest1.dividend * lowest2.dividend) / crossPoint1.dividend).toFixed(6);
                    const addRatio1 = ((lowest1.dividend + lowest2.dividend) / crossPoint1.dividend).toFixed(6);
                    
                    analysis1 = {
                        ratio: ratio1,
                        addRatio: addRatio1,
                        items: [
                            {
                                label: 'ÏµúÏ†ÄÎ∞∞Îãπ1',
                                pair: lowest1.pair,
                                dividend: lowest1.dividend,
                                proportion: (lowest1.dividend / sum1) * 100
                            },
                            {
                                label: 'ÏµúÏ†ÄÎ∞∞Îãπ2',
                                pair: lowest2.pair,
                                dividend: lowest2.dividend,
                                proportion: (lowest2.dividend / sum1) * 100
                            },
                            {
                                label: 'ÍµêÏ∞®Ï†ê',
                                pair: crossPoint1.pair,
                                dividend: crossPoint1.dividend,
                                proportion: (crossPoint1.dividend / sum1) * 100
                            }
                        ]
                    };
                }
            }
            
            // ÍµêÏ∞®Ï†êÎ∂ÑÏÑù2
            if (analysis1 && sortedData.length >= 3) {
                const usedNumbers1 = new Set([
                    ...extractNumbers(analysis1.items[0].pair),
                    ...extractNumbers(analysis1.items[1].pair),
                    ...extractNumbers(analysis1.items[2].pair)
                ]);
                
                const availablePairs = sortedData.filter(item => {
                    const nums = extractNumbers(item.pair);
                    return !nums.some(n => usedNumbers1.has(n));
                });
                
                // Í≥µÌÜµ Ïà´ÏûêÍ∞Ä ÏûàÎäî ÏµúÏ†Ä 2Í∞ú Ïßù Ï∞æÍ∏∞
                let pair2_1 = null;
                let pair2_2 = null;
                let crossPoint2 = null;
                
                for (let i = 0; i < availablePairs.length; i++) {
                    for (let j = i + 1; j < availablePairs.length; j++) {
                        const p1 = availablePairs[i];
                        const p2 = availablePairs[j];
                        
                        const num1_1 = p1.pair[0];
                        const num1_2 = p1.pair[1];
                        const num2_1 = p2.pair[0];
                        const num2_2 = p2.pair[1];
                        
                        let crossNum1, crossNum2;
                        let hasCommon = false;
                        
                        if (num1_1 === num2_1) {
                            crossNum1 = num1_2;
                            crossNum2 = num2_2;
                            hasCommon = true;
                        } else if (num1_1 === num2_2) {
                            crossNum1 = num1_2;
                            crossNum2 = num2_1;
                            hasCommon = true;
                        } else if (num1_2 === num2_1) {
                            crossNum1 = num1_1;
                            crossNum2 = num2_2;
                            hasCommon = true;
                        } else if (num1_2 === num2_2) {
                            crossNum1 = num1_1;
                            crossNum2 = num2_1;
                            hasCommon = true;
                        }
                        
                        if (hasCommon) {
                            const crossPair_1 = crossNum1 + crossNum2;
                            const crossPair_2 = crossNum2 + crossNum1;
                            
                            const crossIdx1 = pairs.indexOf(crossPair_1);
                            const crossIdx2 = pairs.indexOf(crossPair_2);
                            
                            if (crossIdx1 !== -1 || crossIdx2 !== -1) {
                                pair2_1 = p1;
                                pair2_2 = p2;
                                
                                if (crossIdx1 !== -1) {
                                    crossPoint2 = {
                                        pair: crossPair_1,
                                        dividend: dividends[crossIdx1]
                                    };
                                } else {
                                    crossPoint2 = {
                                        pair: crossPair_2,
                                        dividend: dividends[crossIdx2]
                                    };
                                }
                                break;
                            }
                        }
                    }
                    if (pair2_1 && pair2_2 && crossPoint2) break;
                }
                
                if (pair2_1 && pair2_2 && crossPoint2) {
                    const sum2 = pair2_1.dividend + pair2_2.dividend + crossPoint2.dividend;
                    const ratio2 = ((pair2_1.dividend * pair2_2.dividend) / crossPoint2.dividend).toFixed(6);
                    const addRatio2 = ((pair2_1.dividend + pair2_2.dividend) / crossPoint2.dividend).toFixed(6);
                    
                    analysis2 = {
                        ratio: ratio2,
                        addRatio: addRatio2,
                        items: [
                            {
                                label: '1Î≤àÏßù',
                                pair: pair2_1.pair,
                                dividend: pair2_1.dividend,
                                proportion: (pair2_1.dividend / sum2) * 100
                            },
                            {
                                label: '2Î≤àÏßù',
                                pair: pair2_2.pair,
                                dividend: pair2_2.dividend,
                                proportion: (pair2_2.dividend / sum2) * 100
                            },
                            {
                                label: 'ÍµêÏ∞®Ï†ê',
                                pair: crossPoint2.pair,
                                dividend: crossPoint2.dividend,
                                proportion: (crossPoint2.dividend / sum2) * 100
                            }
                        ]
                    };
                }
            }
            
            // ÍµêÏ∞®Ï†êÎ∂ÑÏÑù3
            if (analysis1 && analysis2 && sortedData.length >= 3) {
                const usedNumbers2 = new Set([
                    ...extractNumbers(analysis1.items[0].pair),
                    ...extractNumbers(analysis1.items[1].pair),
                    ...extractNumbers(analysis1.items[2].pair),
                    ...extractNumbers(analysis2.items[0].pair),
                    ...extractNumbers(analysis2.items[1].pair),
                    ...extractNumbers(analysis2.items[2].pair)
                ]);
                
                const availablePairs = sortedData.filter(item => {
                    const nums = extractNumbers(item.pair);
                    return !nums.some(n => usedNumbers2.has(n));
                });
                
                // Í≥µÌÜµ Ïà´ÏûêÍ∞Ä ÏûàÎäî ÏµúÏ†Ä 2Í∞ú Ïßù Ï∞æÍ∏∞
                let pair3_1 = null;
                let pair3_2 = null;
                let crossPoint3 = null;
                
                for (let i = 0; i < availablePairs.length; i++) {
                    for (let j = i + 1; j < availablePairs.length; j++) {
                        const p1 = availablePairs[i];
                        const p2 = availablePairs[j];
                        
                        const num1_1 = p1.pair[0];
                        const num1_2 = p1.pair[1];
                        const num2_1 = p2.pair[0];
                        const num2_2 = p2.pair[1];
                        
                        let crossNum1, crossNum2;
                        let hasCommon = false;
                        
                        if (num1_1 === num2_1) {
                            crossNum1 = num1_2;
                            crossNum2 = num2_2;
                            hasCommon = true;
                        } else if (num1_1 === num2_2) {
                            crossNum1 = num1_2;
                            crossNum2 = num2_1;
                            hasCommon = true;
                        } else if (num1_2 === num2_1) {
                            crossNum1 = num1_1;
                            crossNum2 = num2_2;
                            hasCommon = true;
                        } else if (num1_2 === num2_2) {
                            crossNum1 = num1_1;
                            crossNum2 = num2_1;
                            hasCommon = true;
                        }
                        
                        if (hasCommon) {
                            const crossPair_1 = crossNum1 + crossNum2;
                            const crossPair_2 = crossNum2 + crossNum1;
                            
                            const crossIdx1 = pairs.indexOf(crossPair_1);
                            const crossIdx2 = pairs.indexOf(crossPair_2);
                            
                            if (crossIdx1 !== -1 || crossIdx2 !== -1) {
                                pair3_1 = p1;
                                pair3_2 = p2;
                                
                                if (crossIdx1 !== -1) {
                                    crossPoint3 = {
                                        pair: crossPair_1,
                                        dividend: dividends[crossIdx1]
                                    };
                                } else {
                                    crossPoint3 = {
                                        pair: crossPair_2,
                                        dividend: dividends[crossIdx2]
                                    };
                                }
                                break;
                            }
                        }
                    }
                    if (pair3_1 && pair3_2 && crossPoint3) break;
                }
                
                if (pair3_1 && pair3_2 && crossPoint3) {
                    const sum3 = pair3_1.dividend + pair3_2.dividend + crossPoint3.dividend;
                    const ratio3 = ((pair3_1.dividend * pair3_2.dividend) / crossPoint3.dividend).toFixed(6);
                    const addRatio3 = ((pair3_1.dividend + pair3_2.dividend) / crossPoint3.dividend).toFixed(6);
                    
                    analysis3 = {
                        ratio: ratio3,
                        addRatio: addRatio3,
                        items: [
                            {
                                label: '1ÏúÑ',
                                pair: pair3_1.pair,
                                dividend: pair3_1.dividend,
                                proportion: (pair3_1.dividend / sum3) * 100
                            },
                            {
                                label: '2ÏúÑ',
                                pair: pair3_2.pair,
                                dividend: pair3_2.dividend,
                                proportion: (pair3_2.dividend / sum3) * 100
                            },
                            {
                                label: 'ÍµêÏ∞®Ï†ê',
                                pair: crossPoint3.pair,
                                dividend: crossPoint3.dividend,
                                proportion: (crossPoint3.dividend / sum3) * 100
                            }
                        ]
                    };
                }
            }
            
            // 10Î≤àÏß∏ Ïù¥ÌõÑ Ï∂îÍ∞Ä ÍµêÏ∞®Ï†ê Î∂ÑÏÑù
            if (sortedData.length > 9) {
                const usedNumbers = new Set();
                if (analysis1) {
                    analysis1.items.forEach(item => {
                        extractNumbers(item.pair).forEach(n => usedNumbers.add(n));
                    });
                }
                if (analysis2) {
                    analysis2.items.forEach(item => {
                        extractNumbers(item.pair).forEach(n => usedNumbers.add(n));
                    });
                }
                if (analysis3) {
                    analysis3.items.forEach(item => {
                        extractNumbers(item.pair).forEach(n => usedNumbers.add(n));
                    });
                }
                
                let analysisCount = 4;
                let maxAttempts = 10;
                
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    const remainingPairs = sortedData.filter(item => {
                        const nums = extractNumbers(item.pair);
                        return !nums.some(n => usedNumbers.has(n));
                    });
                    if (remainingPairs.length >= 2) {
                    }
                    
                    if (remainingPairs.length < 1) {
                        break;
                    }
                    
                    let foundPair1 = null;
                    let foundPair2 = null;
                    let foundCrossPoint = null;
                    let foundMatch = false;
                    
                    // Î®ºÏ†Ä ÍµêÏ∞®Ï†êÏù¥ ÏûàÎäî Í≤ΩÏö∞ Ï∞æÍ∏∞
                    for (let i = 0; i < remainingPairs.length && !foundMatch; i++) {
                        for (let j = i + 1; j < remainingPairs.length && !foundMatch; j++) {
                            const p1 = remainingPairs[i];
                            const p2 = remainingPairs[j];
                            
                            const num1_1 = p1.pair[0];
                            const num1_2 = p1.pair[1];
                            const num2_1 = p2.pair[0];
                            const num2_2 = p2.pair[1];
                            
                            let crossNum1, crossNum2;
                            let hasCommon = false;
                            
                            if (num1_1 === num2_1) {
                                crossNum1 = num1_2;
                                crossNum2 = num2_2;
                                hasCommon = true;
                            } else if (num1_1 === num2_2) {
                                crossNum1 = num1_2;
                                crossNum2 = num2_1;
                                hasCommon = true;
                            } else if (num1_2 === num2_1) {
                                crossNum1 = num1_1;
                                crossNum2 = num2_2;
                                hasCommon = true;
                            } else if (num1_2 === num2_2) {
                                crossNum1 = num1_1;
                                crossNum2 = num2_1;
                                hasCommon = true;
                            }
                            
                            if (hasCommon) {
                                const crossPair = [crossNum1, crossNum2].sort().join('');
                                const crossData = sortedData.find(item => {
                                    if (item.pair !== crossPair) return false;
                                    const itemNums = extractNumbers(item.pair);
                                    return !itemNums.some(n => usedNumbers.has(n));
                                });
                                
                                if (crossData) {
                                    foundPair1 = p1;
                                    foundPair2 = p2;
                                    foundCrossPoint = crossData;
                                    foundMatch = true;
                                }
                            }
                        }
                    }
                    
                    // ÍµêÏ∞®Ï†êÏùÑ Î™ª Ï∞æÏïòÏúºÎ©¥ 1ÏúÑ, 2ÏúÑÎßåÏù¥ÎùºÎèÑ ÌëúÏãú
                    if (!foundMatch && remainingPairs.length >= 1) {
                        foundPair1 = remainingPairs[0];
                        foundPair2 = remainingPairs.length >= 2 ? remainingPairs[1] : null;
                        foundCrossPoint = null;
                        foundMatch = true;
                    }
                    
                    if (foundMatch && foundPair1) {
                        let items = [
                            {
                                label: '1ÏúÑ',
                                pair: foundPair1.pair,
                                dividend: foundPair1.dividend,
                                proportion: 0
                            }
                        ];
                        
                        if (foundPair2) {
                            items.push({
                                label: '2ÏúÑ',
                                pair: foundPair2.pair,
                                dividend: foundPair2.dividend,
                                proportion: 0
                            });
                        } else {
                            items.push({
                                label: '2ÏúÑ',
                                pair: '-',
                                dividend: 0,
                                proportion: 0
                            });
                        }
                        
                        if (foundCrossPoint) {
                            items.push({
                                label: 'ÍµêÏ∞®Ï†ê',
                                pair: foundCrossPoint.pair,
                                dividend: foundCrossPoint.dividend,
                                proportion: 0
                            });
                        } else {
                            items.push({
                                label: 'ÍµêÏ∞®Ï†ê',
                                pair: '-',
                                dividend: 0,
                                proportion: 0
                            });
                        }
                        
                        // ÎπÑÏú® Í≥ÑÏÇ∞
                        const sum = items.reduce((s, item) => s + item.dividend, 0);
                        items.forEach(item => {
                            item.proportion = sum > 0 ? (item.dividend / sum) * 100 : 0;
                        });
                        
                        let ratio = '-';
                        let addRatio = '-';
                        
                        if (foundCrossPoint && foundCrossPoint.dividend > 0) {
                            ratio = (foundPair1.dividend * foundPair2.dividend / foundCrossPoint.dividend).toFixed(7);
                            addRatio = ((foundPair1.dividend + foundPair2.dividend) / foundCrossPoint.dividend).toFixed(6);
                        }
                        
                        additionalAnalyses.push({
                            number: analysisCount,
                            ratio: ratio,
                            addRatio: addRatio,
                            items: items,
                            hasCrossPoint: !!foundCrossPoint
                        });
                        
                        extractNumbers(foundPair1.pair).forEach(n => usedNumbers.add(n));
                        if (foundPair2) {
                            extractNumbers(foundPair2.pair).forEach(n => usedNumbers.add(n));
                        }
                        if (foundCrossPoint) {
                            extractNumbers(foundCrossPoint.pair).forEach(n => usedNumbers.add(n));
                        }
                        
                        analysisCount++;
                    } else {
                        break;
                    }
                }
            }
            
            // ÎπàÎèÑ Î∂ÑÏÑù
            const allCircledNums = [];
            for (let char of inputData) {
                if (circledNumbers.includes(char)) {
                    allCircledNums.push(char);
                }
            }
            
            const lines = [];
            for (let i = 0; i < allCircledNums.length; i += 6) {
                const lineNums = allCircledNums.slice(i, i + 6);
                if (lineNums.length > 0) {
                    lines.push(lineNums.join(' '));
                }
            }
            
            const countNumbers = (text) => {
                const counts = {};
                circledNumbers.forEach(num => {
                    const matches = text.match(new RegExp(num, 'g'));
                    counts[num] = matches ? matches.length : 0;
                });
                return counts;
            };

            const lines1to3 = lines.slice(0, 3).join('\n');
            const result1to3 = countNumbers(lines1to3);
            const lines4to6 = lines.slice(3, 6).join('\n');
            const result4to6 = countNumbers(lines4to6);
            const lines7to10 = lines.slice(6, 10).join('\n');
            const result7to10 = countNumbers(lines7to10);
            const lines1to10 = lines.slice(0, 10).join('\n');
            const result1to10 = countNumbers(lines1to10);

            let result11to13 = null, result14to16 = null, result17to20 = null, result11to20 = null, resultCumulative20 = null;
            if (lines.length > 10) {
                result11to13 = countNumbers(lines.slice(10, 13).join('\n'));
                result14to16 = countNumbers(lines.slice(13, 16).join('\n'));
                result17to20 = countNumbers(lines.slice(16, 20).join('\n'));
                result11to20 = countNumbers(lines.slice(10, 20).join('\n'));
                resultCumulative20 = countNumbers(lines.slice(0, 20).join('\n'));
            }

            let result21to23 = null, result24to26 = null, result27to30 = null, result21to30 = null, resultCumulative30 = null;
            if (lines.length > 20) {
                result21to23 = countNumbers(lines.slice(20, 23).join('\n'));
                result24to26 = countNumbers(lines.slice(23, 26).join('\n'));
                result27to30 = countNumbers(lines.slice(26, 30).join('\n'));
                result21to30 = countNumbers(lines.slice(20, 30).join('\n'));
                resultCumulative30 = countNumbers(lines.slice(0, 30).join('\n'));
            }

            let result31to33 = null, result34to36 = null, result37to40 = null, result31to40 = null, resultCumulative40 = null;
            if (lines.length > 30) {
                result31to33 = countNumbers(lines.slice(30, 33).join('\n'));
                result34to36 = countNumbers(lines.slice(33, 36).join('\n'));
                result37to40 = countNumbers(lines.slice(36, 40).join('\n'));
                result31to40 = countNumbers(lines.slice(30, 40).join('\n'));
                resultCumulative40 = countNumbers(lines.slice(0, 40).join('\n'));
            }

            let result41to43 = null, result44to46 = null, result47to50 = null, result41to50 = null, resultCumulative50 = null;
            if (lines.length > 40) {
                result41to43 = countNumbers(lines.slice(40, 43).join('\n'));
                result44to46 = countNumbers(lines.slice(43, 46).join('\n'));
                result47to50 = countNumbers(lines.slice(46, 50).join('\n'));
                result41to50 = countNumbers(lines.slice(40, 50).join('\n'));
                resultCumulative50 = countNumbers(lines.slice(0, 50).join('\n'));
            }

            results = {
                first10: { section1: result1to3, section2: result4to6, section3: result7to10, all: result1to10 },
                second10: result11to20 ? { section1: result11to13, section2: result14to16, section3: result17to20, all: result11to20, cumulative: resultCumulative20 } : null,
                third10: result21to30 ? { section1: result21to23, section2: result24to26, section3: result27to30, all: result21to30, cumulative: resultCumulative30 } : null,
                fourth10: result31to40 ? { section1: result31to33, section2: result34to36, section3: result37to40, all: result31to40, cumulative: resultCumulative40 } : null,
                fifth10: result41to50 ? { section1: result41to43, section2: result44to46, section3: result47to50, all: result41to50, cumulative: resultCumulative50 } : null
            };

            renderResults();
            
            // index2222 Î∂ÑÏÑù Ïã§Ìñâ
            setTimeout(function() {
                try {
                    analyzeData2();
                } catch(e) {
                    console.error('index2222 Ïò§Î•ò:', e);
                }
            }, 150);
        }

        function getGradientColor(count, minCount, maxCount) {
            if (maxCount === 0) return 'rgb(96, 165, 250)';
            const ratio = count / maxCount;
            let r, g, b;
            if (ratio <= 0.5) {
                const normalizedRatio = ratio * 2;
                r = Math.round(96 + (255 - 96) * normalizedRatio);
                g = Math.round(165 + (255 - 165) * normalizedRatio);
                b = Math.round(250 + (255 - 250) * normalizedRatio);
            } else {
                const normalizedRatio = (ratio - 0.5) * 2;
                r = Math.round(255 + (239 - 255) * normalizedRatio);
                g = Math.round(255 + (68 - 255) * normalizedRatio);
                b = Math.round(255 + (68 - 255) * normalizedRatio);
            }
            return `rgb(${r}, ${g}, ${b})`;
        }

        function getAddRatioColor(value, minValue, maxValue) {
            if (value < minValue) value = minValue;
            if (value > maxValue) value = maxValue;
            const ratio = (value - minValue) / (maxValue - minValue);
            let r, g, b;
            if (ratio <= 0.5) {
                const normalizedRatio = ratio * 2;
                r = Math.round(96 + (255 - 96) * normalizedRatio);
                g = Math.round(165 + (255 - 165) * normalizedRatio);
                b = Math.round(250 + (255 - 250) * normalizedRatio);
            } else {
                const normalizedRatio = (ratio - 0.5) * 2;
                r = Math.round(255 + (239 - 255) * normalizedRatio);
                g = Math.round(255 + (68 - 255) * normalizedRatio);
                b = Math.round(255 + (68 - 255) * normalizedRatio);
            }
            return `rgb(${r}, ${g}, ${b})`;
        }

        function getDividendColor(dividend) {
            if (dividend <= 1.0) {
                return 'rgb(96, 165, 250)';
            } else if (dividend >= 5.0 && dividend < 7.0) {
                return 'rgb(251, 146, 60)';
            } else if (dividend >= 7.0) {
                return 'rgb(239, 68, 68)';
            } else {
                return 'transparent';
            }
        }

        function getTotalRatioColor(value) {
            if (value < 100) {
                return 'rgb(239, 68, 68)'; // Îπ®Í∞ÑÏÉâ
            } else if (value >= 100 && value < 200) {
                return 'rgb(251, 146, 60)'; // Ï£ºÌô©ÏÉâ
            } else {
                return 'white'; // ÌïòÏñÄÏÉâ
            }
        }

        function renderTable(data, title, hasCumulative = false) {
            if (!data) return '';
            const circledNumbers = ['‚ë†', '‚ë°', '‚ë¢', '‚ë£', '‚ë§', '‚ë•', '‚ë¶', '‚ëß', '‚ë®', '‚ë©', '‚ë™', '‚ë´', '‚ë¨', '‚ë≠', '‚ëÆ', '‚ëØ'];
            const getMax = (dataObj) => Math.max(...Object.values(dataObj));
            const maxValues = {
                section1: getMax(data.section1), section2: getMax(data.section2),
                section3: getMax(data.section3), all: getMax(data.all)
            };
            if (hasCumulative && data.cumulative) maxValues.cumulative = getMax(data.cumulative);
            const colWidth = hasCumulative ? '9%' : '11%';
            const colWidthValue = hasCumulative ? '11%' : '14%';

            let html = `<div class="table-container">
                <div class="table-title">${title}</div>
                <table>
                    <colgroup>
                        <col style="width: ${colWidth}" /><col style="width: ${colWidthValue}" />
                        <col style="width: ${colWidth}" /><col style="width: ${colWidthValue}" />
                        <col style="width: ${colWidth}" /><col style="width: ${colWidthValue}" />
                        <col style="width: ${colWidth}" /><col style="width: ${colWidthValue}" />
                        ${hasCumulative ? `<col style="width: ${colWidth}" /><col style="width: ${colWidthValue}" />` : ''}
                    </colgroup>
                    <thead><tr>
                        <th>Ï≤´Î∂ÄÎ∂Ñ</th><th></th>
                        <th>Ï§ëÍ∞Ñ</th><th></th>
                        <th>ÏïÑÎû´Î∂ÄÎ∂Ñ</th><th></th>
                        <th>Ï†ÑÏ≤¥</th><th></th>
                        ${hasCumulative ? `<th class="orange-bg">ÎàÑÏ†ÅÏ†ÑÏ≤¥</th><th class="orange-bg"></th>` : ''}
                    </tr></thead><tbody>`;

            circledNumbers.forEach(num => {
                html += `<tr>
                    <td class="yellow-bg">${num}</td>
                    <td class="value-cell" style="background-color: ${getGradientColor(data.section1[num], 0, maxValues.section1)}">${data.section1[num]}</td>
                    <td class="yellow-bg">${num}</td>
                    <td class="value-cell" style="background-color: ${getGradientColor(data.section2[num], 0, maxValues.section2)}">${data.section2[num]}</td>
                    <td class="yellow-bg">${num}</td>
                    <td class="value-cell" style="background-color: ${getGradientColor(data.section3[num], 0, maxValues.section3)}">${data.section3[num]}</td>
                    <td class="yellow-bg">${num}</td>
                    <td class="value-cell" style="background-color: ${getGradientColor(data.all[num], 0, maxValues.all)}">${data.all[num]}</td>
                    ${hasCumulative && data.cumulative ? `
                        <td class="yellow-bg">${num}</td>
                        <td class="value-cell orange-bg" style="background-color: ${getGradientColor(data.cumulative[num], 0, maxValues.cumulative)}">${data.cumulative[num]}</td>
                    ` : ''}
                </tr>`;
            });
            return html + `</tbody></table></div>`;
        }

        function renderResults() {
            let html = '<div>';

            // ÍµêÏ∞®Ï†êÎ∂ÑÏÑù1
            if (analysis1) {
                html += `<div class="analysis-box">
                    <div class="analysis-title">üìä ÍµêÏ∞®Ï†êÎ∂ÑÏÑù1</div>
                    <div class="cards-grid">`;
                analysis1.items.forEach((item, idx) => {
                    const bgColor = idx === 0 ? getDividendColor(item.dividend) : 'transparent';
                    html += `<div class="card">
                        <div class="card-label">${item.label}</div>
                        <div class="number-display">
                            ${item.pair.split('').map(c => `<span>${c}</span>`).join('')}
                        </div>
                        <div class="dividend-value" style="background-color: ${bgColor}">${item.dividend}</div>
                        <div class="proportion-value">${item.proportion.toFixed(2)}%</div>
                    </div>`;
                });
                html += `</div><div class="ratio-grid">
                    <div class="ratio-box yellow">
                        <div class="ratio-label" style="color: #78716C">ÎπÑÏú®</div>
                        <div class="ratio-value" style="color: #F59E0B">${analysis1.ratio}</div>
                        <div class="ratio-formula" style="color: #78716C">= (${analysis1.items[0].dividend} √ó ${analysis1.items[1].dividend}) / ${analysis1.items[2].dividend}</div>
                    </div>
                    <div class="ratio-box" style="background-color: ${getAddRatioColor(parseFloat(analysis1.addRatio), 0.1, 2.0)}">
                        <div class="ratio-label" style="color: black">ÎçîÌïòÍ∏∞ ÎπÑÏú®</div>
                        <div class="ratio-value" style="color: black">${analysis1.addRatio}</div>
                        <div class="ratio-formula" style="color: black">= (${analysis1.items[0].dividend} + ${analysis1.items[1].dividend}) / ${analysis1.items[2].dividend}</div>
                    </div>
                </div></div>`;
            }

            // ÍµêÏ∞®Ï†êÎ∂ÑÏÑù2
            if (analysis2) {
                html += `<div class="analysis-box">
                    <div class="analysis-title">üìà ÍµêÏ∞®Ï†êÎ∂ÑÏÑù2</div>
                    <div class="cards-grid">`;
                analysis2.items.forEach(item => {
                    html += `<div class="card">
                        <div class="card-label">${item.label}</div>
                        <div class="number-display">
                            ${item.pair.split('').map(c => `<span>${c}</span>`).join('')}
                        </div>
                        <div class="dividend-value">${item.dividend}</div>
                        <div class="proportion-value">${item.proportion.toFixed(2)}%</div>
                    </div>`;
                });
                html += `</div><div class="ratio-grid">
                    <div class="ratio-box yellow">
                        <div class="ratio-label" style="color: #78716C">ÎπÑÏú®</div>
                        <div class="ratio-value" style="color: #F59E0B">${analysis2.ratio}</div>
                        <div class="ratio-formula" style="color: #78716C">= (${analysis2.items[0].dividend} √ó ${analysis2.items[1].dividend}) / ${analysis2.items[2].dividend}</div>
                    </div>
                    <div class="ratio-box" style="background-color: ${getAddRatioColor(parseFloat(analysis2.addRatio), 0.1, 2.0)}">
                        <div class="ratio-label" style="color: black">ÎçîÌïòÍ∏∞ ÎπÑÏú®</div>
                        <div class="ratio-value" style="color: black">${analysis2.addRatio}</div>
                        <div class="ratio-formula" style="color: black">= (${analysis2.items[0].dividend} + ${analysis2.items[1].dividend}) / ${analysis2.items[2].dividend}</div>
                    </div>
                </div></div>`;
            }

            // ÍµêÏ∞®Ï†êÎ∂ÑÏÑù3
            if (analysis3) {
                html += `<div class="analysis-box">
                    <div class="analysis-title">üéØ ÍµêÏ∞®Ï†êÎ∂ÑÏÑù3</div>
                    <div class="cards-grid">`;
                analysis3.items.forEach(item => {
                    html += `<div class="card">
                        <div class="card-label">${item.label}</div>
                        <div class="number-display">
                            ${item.pair.split('').map(c => `<span>${c}</span>`).join('')}
                        </div>
                        <div class="dividend-value">${item.dividend}</div>
                        <div class="proportion-value">${item.proportion.toFixed(2)}%</div>
                    </div>`;
                });
                html += `</div><div class="ratio-grid">
                    <div class="ratio-box yellow">
                        <div class="ratio-label" style="color: #78716C">ÎπÑÏú®</div>
                        <div class="ratio-value" style="color: #F59E0B">${analysis3.ratio}</div>
                        <div class="ratio-formula" style="color: #78716C">= (${analysis3.items[0].dividend} √ó ${analysis3.items[1].dividend}) / ${analysis3.items[2].dividend}</div>
                    </div>
                    <div class="ratio-box" style="background-color: ${getAddRatioColor(parseFloat(analysis3.addRatio), 0.1, 2.0)}">
                        <div class="ratio-label" style="color: black">ÎçîÌïòÍ∏∞ ÎπÑÏú®</div>
                        <div class="ratio-value" style="color: black">${analysis3.addRatio}</div>
                        <div class="ratio-formula" style="color: black">= (${analysis3.items[0].dividend} + ${analysis3.items[1].dividend}) / ${analysis3.items[2].dividend}</div>
                    </div>
                </div></div>`;
            }

            // Ï∂îÍ∞Ä ÍµêÏ∞®Ï†ê Î∂ÑÏÑù Î†åÎçîÎßÅ
            if (additionalAnalyses && additionalAnalyses.length > 0) {
                additionalAnalyses.forEach(analysis => {
                    html += `<div class="analysis-box">
                        <div class="analysis-title">üéØ ÍµêÏ∞®Ï†êÎ∂ÑÏÑù${analysis.number}</div>
                        <div class="cards-grid">`;
                    
                    analysis.items.forEach((item, idx) => {
                        const bgColor = idx === 0 ? getDividendColor(item.dividend) : 'transparent';
                        
                        if (item.pair === '-') {
                            html += `<div class="card" style="opacity: 0.5;">
                                <div class="card-label">${item.label}</div>
                                <div class="number-display">
                                    <span>-</span>
                                </div>
                                <div class="dividend-value" style="background-color: #ccc">ÏóÜÏùå</div>
                                <div class="proportion-value">-</div>
                            </div>`;
                        } else {
                            html += `<div class="card">
                                <div class="card-label">${item.label}</div>
                                <div class="number-display">
                                    ${item.pair.split('').map(c => `<span>${c}</span>`).join('')}
                                </div>
                                <div class="dividend-value" style="background-color: ${bgColor}">${item.dividend}</div>
                                <div class="proportion-value">${item.proportion.toFixed(2)}%</div>
                            </div>`;
                        }
                    });
                    
                    html += `</div><div class="ratio-grid">
                        <div class="ratio-box yellow">
                            <div class="ratio-label" style="color: #78716C">ÎπÑÏú®</div>
                            <div class="ratio-value" style="color: #F59E0B">${analysis.ratio}</div>`;
                    
                    if (analysis.hasCrossPoint) {
                        html += `<div class="ratio-formula" style="color: #78716C">= (${analysis.items[0].dividend} √ó ${analysis.items[1].dividend}) / ${analysis.items[2].dividend}</div>`;
                    } else {
                        html += `<div class="ratio-formula" style="color: #78716C">ÍµêÏ∞®Ï†ê ÏóÜÏùå</div>`;
                    }
                    
                    html += `</div>
                        <div class="ratio-box" style="background-color: ${analysis.hasCrossPoint ? getAddRatioColor(parseFloat(analysis.addRatio), 0.1, 2.0) : '#ccc'}">
                            <div class="ratio-label" style="color: black">ÎçîÌïòÍ∏∞ ÎπÑÏú®</div>
                            <div class="ratio-value" style="color: black">${analysis.addRatio}</div>`;
                    
                    if (analysis.hasCrossPoint) {
                        html += `<div class="ratio-formula" style="color: black">= (${analysis.items[0].dividend} + ${analysis.items[1].dividend}) / ${analysis.items[2].dividend}</div>`;
                    } else {
                        html += `<div class="ratio-formula" style="color: black">ÍµêÏ∞®Ï†ê ÏóÜÏùå</div>`;
                    }
                    
                    html += `</div>
                    </div></div>`;
                });
            }


            // Ìï©ÏÇ∞ ÎπÑÏú®
            if (analysis1 && analysis2 && analysis3) {
                const totalAddRatio = (parseFloat(analysis1.addRatio) + parseFloat(analysis2.addRatio) + parseFloat(analysis3.addRatio)).toFixed(6);
                html += `<div class="total-ratio-box" style="background-color: ${getAddRatioColor(parseFloat(totalAddRatio), 2.0, 5.0)}">
                    <div class="total-ratio-title">üìä Ìï©ÏÇ∞ ÎπÑÏú®</div>
                    <div class="total-ratio-value">${totalAddRatio}</div>
                    <div class="total-ratio-formula">= ${analysis1.addRatio} + ${analysis2.addRatio} + ${analysis3.addRatio}</div>
                </div>`;
                
                // Î≥µÏäπÎπÑÏú®
                const bokseungRatio = (analysis3.items[2].dividend / analysis1.items[0].dividend).toFixed(6);
                html += `<div class="total-ratio-box" style="background-color: ${getTotalRatioColor(parseFloat(bokseungRatio))}">
                    <div class="total-ratio-title">üéØ Î≥µÏäπÎπÑÏú®</div>
                    <div class="total-ratio-value">${bokseungRatio}</div>
                    <div class="total-ratio-formula">= ${analysis3.items[2].dividend} √∑ ${analysis1.items[0].dividend}</div>
                </div>`;
            }

            // ÏÉâÏÉÅ ÏïàÎÇ¥
            html += `<div class="info-box">
                <div class="info-title">ÏÉâÏÉÅ ÏïàÎÇ¥</div>
                <div class="gradient-bar">
                    <div class="gradient-box">
                        <div class="color-sample" style="background: rgb(96, 165, 250)"></div>
                        <span>0 (ÏµúÏ†Ä)</span>
                    </div>
                    <div class="gradient-fill"></div>
                    <div class="gradient-box">
                        <div class="color-sample" style="background: rgb(239, 68, 68)"></div>
                        <span>ÏµúÍ≥†</span>
                    </div>
                </div>
                <div class="info-text">Í∞Å Íµ¨Í∞ÑÎ≥ÑÎ°ú ÏÉÅÎåÄÏ†ÅÏù∏ ÎπàÎèÑÏóê Îî∞Îùº ÏÉâÏÉÅÏù¥ Í∑∏ÎùºÎç∞Ïù¥ÏÖòÏúºÎ°ú ÌëúÏãúÎê©ÎãàÎã§.</div>
            </div>`;

            html += renderTable(results.first10, "1-10Ï§Ñ Î∂ÑÏÑù");
            if (results.second10) html += renderTable(results.second10, "11-20Ï§Ñ Î∂ÑÏÑù", true);
            if (results.third10) html += renderTable(results.third10, "21-30Ï§Ñ Î∂ÑÏÑù", true);
            if (results.fourth10) html += renderTable(results.fourth10, "31-40Ï§Ñ Î∂ÑÏÑù", true);
            if (results.fifth10) html += renderTable(results.fifth10, "41-50Ï§Ñ Î∂ÑÏÑù", true);

            document.getElementById('results').innerHTML = html + '</div>';
        }


        // ========== index2222 Ïä§ÌÅ¨Î¶ΩÌä∏ ========== 
        // Î∂ÑÏÑù Ïù¥Î†• Ï†ÄÏû•
        let analysisHistory2 = [];

        // ÎèôÍ∑∏ÎùºÎØ∏ Ïà´ÏûêÎ•º ÏùºÎ∞ò Ïà´ÏûêÎ°ú Î≥ÄÌôò
        function circleToNumber(circle) {
            const circleMap = {
                '‚ë†': 1, '‚ë°': 2, '‚ë¢': 3, '‚ë£': 4, '‚ë§': 5,
                '‚ë•': 6, '‚ë¶': 7, '‚ëß': 8, '‚ë®': 9, '‚ë©': 10,
                '‚ë™': 11, '‚ë´': 12, '‚ë¨': 13, '‚ë≠': 14, '‚ëÆ': 15, '‚ëØ': 16
            };
            return circleMap[circle] || null;
        }

        // ÏùºÎ∞ò Ïà´ÏûêÎ•º ÎèôÍ∑∏ÎùºÎØ∏ Ïà´ÏûêÎ°ú Î≥ÄÌôò
        function numberToCircle(num) {
            const numberMap = {
                1: '‚ë†', 2: '‚ë°', 3: '‚ë¢', 4: '‚ë£', 5: '‚ë§',
                6: '‚ë•', 7: '‚ë¶', 8: '‚ëß', 9: '‚ë®', 10: '‚ë©',
                11: '‚ë™', 12: '‚ë´', 13: '‚ë¨', 14: '‚ë≠', 15: '‚ëÆ', 16: '‚ëØ'
            };
            return numberMap[num] || num.toString();
        }

        function analyzeData2() {
            const input = document.getElementById('inputData').value.trim();
            
            if (!input) {
                alert('Îç∞Ïù¥ÌÑ∞Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            // Îç∞Ïù¥ÌÑ∞ ÌååÏã±
            const pairs = [];
            const lines = input.split('\n');
            
            lines.forEach(line => {
                const items = line.split(/\s+/);
                for (let i = 0; i < items.length - 1; i += 2) {
                    if (items[i] && items[i + 1]) {
                        const pair = items[i].trim();
                        const odds = parseFloat(items[i + 1]);
                        if (pair.length >= 2 && !isNaN(odds)) {
                            pairs.push({ pair, odds });
                        }
                    }
                }
            });

            if (pairs.length === 0) {
                alert('Ïú†Ìö®Ìïú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
                return;
            }

            // Ï†ÑÏ≤¥ Î∞∞Îãπ Ìï©Í≥Ñ
            const totalOdds = pairs.reduce((sum, item) => sum + item.odds, 0);

            // ÎèôÍ∑∏ÎùºÎØ∏ Ïà´ÏûêÎ≥ÑÎ°ú Í∑∏Î£πÌôî
            const groupedData = {};
            
            pairs.forEach(item => {
                const chars = item.pair.split('');
                const numbers = chars.map(c => circleToNumber(c)).filter(n => n !== null);
                
                if (numbers.length >= 2) {
                    numbers.forEach(num => {
                        if (!groupedData[num]) {
                            groupedData[num] = [];
                        }
                        
                        groupedData[num].push({
                            pair: item.pair,
                            numbers: numbers,
                            odds: item.odds
                        });
                    });
                }
            });

            // ÍµêÏ∞®Ï†ê Î∂ÑÏÑù
            const crossPointSets = analyzeCrossPoints(pairs);

            // Î∂ÑÏÑù Ïù¥Î†•Ïóê Ï†ÄÏû•
            analysisHistory2.push({
                timestamp: new Date(),
                crossPointSets: crossPointSets,
                totalOdds: totalOdds
            });

            // Í≤∞Í≥º ÌëúÏãú
            displayResults(groupedData, totalOdds, crossPointSets);
            
            // Ïù¥Î†• Ïπ¥Ïö¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
            updateHistoryCounter2();
        }

        function analyzeCrossPoints(pairs) {
            const crossPointSets = [];
            const usedIndices = new Set();
            const usedNumbers = new Set(); // ÏÇ¨Ïö©Îêú Î™®Îì† Ïà´Ïûê Ï∂îÏ†Å
            
            let pairCounter = 1; // Ïßù ÏàúÎ≤à (1Ïßù, 2Ïßù, 3Ïßù...)
            let iterations = 0;
            
            while (iterations < 3 && usedIndices.size < pairs.length - 1) {
                // 1Î≤àÏß∏ Ïßù Ï∞æÍ∏∞ (ÏÇ¨Ïö©Îêú Ïà´Ïûê Ï†úÏô∏)
                let firstIdx = -1;
                let firstNumbers = null;
                for (let i = 0; i < pairs.length; i++) {
                    if (!usedIndices.has(i)) {
                        const chars = pairs[i].pair.split('');
                        const numbers = chars.map(c => circleToNumber(c)).filter(n => n !== null);
                        
                        // ÏÇ¨Ïö©Îêú Ïà´ÏûêÍ∞Ä ÌïòÎÇòÎèÑ Ìè¨Ìï®ÎêòÏßÄ ÏïäÏùÄ Ïßù Ï∞æÍ∏∞
                        if (numbers.length >= 2 && !numbers.some(n => usedNumbers.has(n))) {
                            firstIdx = i;
                            firstNumbers = numbers;
                            break;
                        }
                    }
                }
                
                if (firstIdx === -1) break;
                
                // 2Î≤àÏß∏ Ïßù Ï∞æÍ∏∞ (ÏÇ¨Ïö©Îêú Ïà´Ïûê Ï†úÏô∏, 1Î≤àÏß∏ ÏßùÍ≥º Í≥µÌÜµ Ïà´Ïûê ÏûàÏñ¥Ïïº Ìï®)
                let secondIdx = -1;
                let secondNumbers = null;
                for (let i = 0; i < pairs.length; i++) {
                    if (i !== firstIdx && !usedIndices.has(i)) {
                        const chars = pairs[i].pair.split('');
                        const numbers = chars.map(c => circleToNumber(c)).filter(n => n !== null);
                        
                        // 1Î≤àÏß∏ ÏßùÍ≥º Í≥µÌÜµ Ïà´ÏûêÍ∞Ä ÏûàÍ≥†, ÏÇ¨Ïö©Îêú Ïà´ÏûêÍ∞Ä Ìè¨Ìï®ÎêòÏßÄ ÏïäÏùÄ Ïßù
                        const hasCommon = numbers.some(n => firstNumbers.includes(n));
                        const hasUsedNumber = numbers.some(n => usedNumbers.has(n) && !firstNumbers.includes(n));
                        
                        if (numbers.length >= 2 && hasCommon && !hasUsedNumber) {
                            secondIdx = i;
                            secondNumbers = numbers;
                            break;
                        }
                    }
                }
                
                if (secondIdx === -1) break;
                
                const first = pairs[firstIdx];
                const second = pairs[secondIdx];
                
                // Í≥µÌÜµ Î≤àÌò∏ Ï∞æÍ∏∞
                const commonNumbers = firstNumbers.filter(n => secondNumbers.includes(n));
                
                // ÍµêÏ∞®Ï†ê Ïà´Ïûê (Í≥µÌÜµ Î≤àÌò∏ Ï†úÏô∏)
                const crossNumbers = [
                    ...firstNumbers.filter(n => !commonNumbers.includes(n)),
                    ...secondNumbers.filter(n => !commonNumbers.includes(n))
                ];
                
                // ÍµêÏ∞®Ï†ê Ïßù Ï∞æÍ∏∞ (ÏàúÏÑú ÏÉÅÍ¥ÄÏóÜÏù¥, Ï§ëÎ≥µ ÌóàÏö©)
                let crossPoint = null;
                if (crossNumbers.length === 2) {
                    const [num1, num2] = crossNumbers;
                    crossPoint = pairs.find((p) => {
                        const pNumbers = p.pair.split('').map(c => circleToNumber(c)).filter(n => n !== null);
                        return (pNumbers.includes(num1) && pNumbers.includes(num2)) ||
                               (pNumbers.includes(num2) && pNumbers.includes(num1));
                    });
                }
                
                crossPointSets.push({
                    first: {
                        numbers: firstNumbers,
                        pair: first.pair,
                        odds: first.odds,
                        pairNumber: pairCounter // Ïßù Î≤àÌò∏
                    },
                    second: {
                        numbers: secondNumbers,
                        pair: second.pair,
                        odds: second.odds,
                        pairNumber: pairCounter + 1 // Ïßù Î≤àÌò∏
                    },
                    crossPoint: crossPoint ? {
                        numbers: crossNumbers,
                        pair: crossPoint.pair,
                        odds: crossPoint.odds,
                        formula: `=(${first.odds.toFixed(1)}*${second.odds.toFixed(1)})/${crossPoint.odds.toFixed(1)}`,
                        result: ((first.odds * second.odds) / crossPoint.odds).toFixed(3)
                    } : {
                        numbers: crossNumbers,
                        pair: 'ÏóÜÏùå',
                        odds: null,
                        formula: 'ÍµêÏ∞®Ï†ê ÏóÜÏùå',
                        result: null
                    }
                });
                
                // ÏÇ¨Ïö©Ìïú Ïù∏Îç±Ïä§ ÌëúÏãú
                usedIndices.add(firstIdx);
                usedIndices.add(secondIdx);
                if (crossPoint) {
                    const crossIdx = pairs.findIndex(p => p.pair === crossPoint.pair);
                    if (crossIdx !== -1) usedIndices.add(crossIdx);
                }
                
                // ÏÇ¨Ïö©Îêú Ïà´Ïûê Ï∂îÍ∞Ä (ÎàÑÏ†Å)
                firstNumbers.forEach(n => usedNumbers.add(n));
                secondNumbers.forEach(n => usedNumbers.add(n));
                if (crossPoint && crossPoint.odds) {
                    crossNumbers.forEach(n => usedNumbers.add(n));
                }
                
                pairCounter += 2; // Îã§Ïùå ÏÑ∏Ìä∏Îäî 3Ïßù, 4Ïßù...
                iterations++;
            }
            
            return crossPointSets;
        }

        function displayResults(groupedData, totalOdds, crossPointSets) {            let html = '';                        const sortedNumbers = Object.keys(groupedData).map(Number).sort((a, b) => a - b);                        const summaryData = sortedNumbers.map(num => {                const items = groupedData[num];                const sumOdds = items.reduce((sum, item) => sum + item.odds, 0);                const sumRatio = (sumOdds / (totalOdds * 2) * 100);                return {                    num: num,                    count: items.length,                    sumOdds: sumOdds,                    sumRatio: sumRatio                };            });            summaryData.sort((a, b) => a.sumRatio - b.sumRatio);            html += `                <div class="number-section summary">                    <div class="number-header">                        <span class="number-badge red">üìä</span>                        <span>Ï†ÑÏ≤¥ Ïà´ÏûêÎ≥Ñ Î∞∞Îãπ Ìï©Í≥Ñ (ÎπÑÏ§ë ÎÇÆÏùÄ Ïàú)</span>                    </div>                                        <div class="table-wrapper">                        <table class="data-table">                            <thead class="red">                                <tr>                                    <th>ÎèôÍ∑∏ÎùºÎØ∏<br/>Ïà´Ïûê</th>                                    <th>Ï°∞Ìï©<br/>Í∞úÏàò</th>                                    <th>Î∞∞Îãπ<br/>Ìï©Í≥Ñ</th>                                    <th>ÎπÑÏ§ë<br/>Ìï©Í≥Ñ(%)</th>                                </tr>                            </thead>                            <tbody>            `;                        summaryData.forEach(data => {                html += `                    <tr>                        <td class="pair-cell">${data.num}</td>                        <td>${data.count}</td>                        <td class="odds-cell">${data.sumOdds.toFixed(1)}</td>                        <td class="ratio-cell">${data.sumRatio.toFixed(2)}%</td>                    </tr>                `;            });                        html += `                        </tbody>                    </table>                    </div>                    <div class="summary">                        <div class="summary-text">                            üí∞ Ï†ÑÏ≤¥ Î∞∞Îãπ Ìï©Í≥Ñ: ${totalOdds.toFixed(1)}                        </div>                    </div>                    <div class="summary" style="margin-top: 10px; background: #e8f5e9; border-left-color: #4caf50;">                        <div class="summary-text" style="color: #2e7d32;">                            üìä ÎπÑÏ§ë ÌÜµÍ≥Ñ Î∂ÑÏÑù (Î∞∞ÎãπÌï©Í≥Ñ Í∏∞Ï§Ä)<br/>                            ‚Ä¢ ÌèâÍ∑†: ${(summaryData.reduce((sum, d) => sum + d.sumOdds, 0) / summaryData.length).toFixed(2)}<br/>                            ‚Ä¢ ÌëúÏ§ÄÌé∏Ï∞®: ${(() => {                                const mean = summaryData.reduce((sum, d) => sum + d.sumOdds, 0) / summaryData.length;                                const variance = summaryData.reduce((sum, d) => sum + Math.pow(d.sumOdds - mean, 2), 0) / summaryData.length;                                return Math.sqrt(variance).toFixed(2);                            })()}<br/>                            ‚Ä¢ ÏµúÎåÄ-ÏµúÏÜå Ï∞®Ïù¥: ${(Math.max(...summaryData.map(d => d.sumOdds)) - Math.min(...summaryData.map(d => d.sumOdds))).toFixed(2)}                        </div>                    </div>                    <div class="chart-container">                        <div class="chart-title">üìà ÎèôÍ∑∏ÎùºÎØ∏ Ïà´ÏûêÎ≥Ñ ÎπÑÏ§ë Î∂ÑÌè¨</div>            `;                        const maxRatio = Math.max(...summaryData.map(d => d.sumRatio));            summaryData.forEach(data => {                const widthPercent = (data.sumRatio / maxRatio * 100);                html += `                    <div class="chart-bar">                        <div class="chart-label">${data.num}</div>                        <div class="chart-bar-container">                            <div class="chart-bar-fill" style="width: ${widthPercent}%">                                <span class="chart-value">${data.sumRatio.toFixed(2)}%</span>                            </div>                        </div>                    </div>                `;            });                        html += `                    </div>                </div>            `;            html += `                <div class="number-section">                    <div class="number-header">                        <span class="number-badge blue">üìã</span>                        <span>Í∞Å Ïà´ÏûêÎ≥Ñ Ï≤´ Î≤àÏß∏ Ï°∞Ìï© (Î∞∞Îãπ ÎπÑÏ§ë ÎÇÆÏùÄ Ïàú)</span>                    </div>                                        <div class="table-wrapper">                        <table class="data-table">                            <thead class="blue">                                <tr>                                    <th>ÏàúÏÑú</th>                                    <th>ÎèôÍ∑∏ÎùºÎØ∏<br/>ÏïàÏùò Ïà´Ïûê</th>                                    <th>ÏÉÅÎåÄ<br/>Ïà´Ïûê</th>                                    <th>Î∞∞Îãπ</th>                                    <th>Î∞∞Îãπ<br/>ÎπÑÏ§ë(%)</th>                                </tr>                            </thead>                            <tbody>            `;                        // Í∞Å Ïà´ÏûêÎ≥Ñ Ï≤´ Î≤àÏß∏ Ï°∞Ìï© Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            const firstCombinations = [];
            sortedNumbers.forEach(num => {
                const items = groupedData[num];
                if (items && items.length > 0) {
                    const firstItem = items[0];
                    const sumOdds = items.reduce((sum, item) => sum + item.odds, 0);
                    const otherNumber = firstItem.numbers.find(n => n !== num);
                    const pageRatio = (firstItem.odds / sumOdds * 100);
                    
                    firstCombinations.push({
                        num: num,
                        numbers: firstItem.numbers,
                        otherNumber: otherNumber,
                        odds: firstItem.odds,
                        pageRatio: pageRatio
                    });
                }
            });
            
            // Î∞∞Îãπ ÎπÑÏ§ë ÎÇÆÏùÄ ÏàúÏúºÎ°ú Ï†ïÎ†¨
            firstCombinations.sort((a, b) => a.pageRatio - b.pageRatio);
            
            // ÌÖåÏù¥Î∏î Ï∂úÎ†•
            firstCombinations.forEach((item) => {
                html += `
                    <tr>
                        <td>${item.num}</td>
                        <td class="pair-cell">${item.numbers.join(', ')}</td>
                        <td class="pair-cell">${item.otherNumber}</td>
                        <td class="odds-cell">${item.odds.toFixed(1)}</td>
                        <td class="ratio-cell">${item.pageRatio.toFixed(2)}%</td>
                    </tr>
                `;
            });                        html += `                            </tbody>                        </table>                    </div>                </div>            `;            sortedNumbers.forEach(num => {                const items = groupedData[num];                const sumOdds = items.reduce((sum, item) => sum + item.odds, 0);                                html += `                    <div class="number-section">                        <div class="number-header">                            <span class="number-badge">${numberToCircle(num)}</span>                            <span>${numberToCircle(num)}Î≤àÏù¥ Ìè¨Ìï®Îêú Ï°∞Ìï©</span>                        </div>                                                <div class="table-wrapper">                        <table class="data-table">                            <thead>                                <tr>                                    <th>ÏàúÏÑú</th>                                    <th>ÎèôÍ∑∏ÎùºÎØ∏<br/>ÏïàÏùò Ïà´Ïûê</th>                                    <th>ÏÉÅÎåÄ<br/>Ïà´Ïûê</th>                                    <th>Î∞∞Îãπ</th>                                    <th>Î∞∞Îãπ<br/>ÎπÑÏ§ë(%)</th>                                </tr>                            </thead>                            <tbody>                `;                                items.forEach((item, index) => {                    const otherNumber = item.numbers.find(n => n !== num);                    const pageRatio = (item.odds / sumOdds * 100).toFixed(2);                                        html += `                        <tr>                            <td>${index + 1}</td>                            <td class="pair-cell">${item.numbers.join(', ')}</td>                            <td class="pair-cell">${otherNumber}</td>                            <td class="odds-cell">${item.odds.toFixed(1)}</td>                            <td class="ratio-cell">${pageRatio}%</td>                        </tr>                    `;                });                                html += `                            </tbody>                        </table>                        </div>                                                <div class="summary">                            <div class="summary-text">                                üìå ${numberToCircle(num)}Î≤à Ìï©Í≥Ñ: Î∞∞Îãπ ${sumOdds.toFixed(1)} / Ï°∞Ìï© Í∞úÏàò ${items.length}Í∞ú                            </div>                        </div>                    </div>                `;            });            if (analysisHistory2.length > 0) {                html += `<div class="save-status">                    <div class="save-status-text">üíæ Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•</div>                    <div class="save-buttons">                        <button class="excel-btn" onclick="exportToExcel2()">üì• ÏóëÏÖÄ Îã§Ïö¥Î°úÎìú (${analysisHistory2.length}Í∞ú ÌöåÏ∞®)</button>                    </div>                </div>`;            }                        document.getElementById('results2').innerHTML = html;        }
        function clearAll2() {
            document.getElementById('inputData').value = '';
            document.getElementById('results2').innerHTML = '';
        }

        function updateHistoryCounter2() {
            const counter = document.getElementById('historyCounter2');
            if (counter) {
                counter.textContent = `Ï†ÄÏû•Îêú ÌöåÏ∞®: ${analysisHistory2.length}Í∞ú`;
            }
        }

        function clearHistory2() {
            if (analysisHistory2.length === 0) {
                alert('Ï†ÄÏû•Îêú ÌöåÏ∞®Í∞Ä ÏóÜÏäµÎãàÎã§.');
                return;
            }
            
            if (confirm(`${analysisHistory2.length}Í∞ú ÌöåÏ∞®Î•º Î™®Îëê ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                analysisHistory2 = [];
                updateHistoryCounter2();
                alert('Î™®Îì† ÌöåÏ∞®Í∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.');
            }
        }

        async function downloadExcel2() {
            if (analysisHistory2.length === 0) {
                alert('Ï†ÄÏû•Îêú ÌöåÏ∞®Í∞Ä ÏóÜÏäµÎãàÎã§. Î®ºÏ†Ä Î∂ÑÏÑùÏùÑ ÏßÑÌñâÌï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            // SheetJS ÎùºÏù¥Î∏åÎü¨Î¶¨ Î°úÎìú ÌôïÏù∏
            if (typeof XLSX === 'undefined') {
                alert('ÏóëÏÖÄ ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º Î°úÎî© Ï§ëÏûÖÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            // ÌååÏùºÎ™Ö ÏûÖÎ†• Î∞õÍ∏∞
            const defaultFileName = `Î∞∞ÎãπÎ∂ÑÏÑù_${new Date().toISOString().slice(0, 10)}`;
            const userFileName = prompt('ÌååÏùºÎ™ÖÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî (ÌôïÏû•Ïûê Ï†úÏô∏):', defaultFileName);
            
            if (userFileName === null) {
                return;
            }
            
            const fileName = (userFileName.trim() || defaultFileName) + '.xlsx';

            try {
                // ÏóëÏÖÄ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                const ws_data = [];
                
                // ÏµúÎåÄ Ïà´Ïûê Í∞úÏàò Í≥ÑÏÇ∞
                let maxNumbers = 0;
                analysisHistory2.forEach(history => {
                    if (history.crossPointSets && history.crossPointSets.length > 0) {
                        // Í∞Å historyÏùò Í≥†Ïú† Ïà´Ïûê Í∞úÏàò Í≥ÑÏÇ∞
                        const uniqueNumbers = new Set();
                        history.crossPointSets.forEach(set => {
                            set.first.numbers.forEach(n => uniqueNumbers.add(n));
                            set.second.numbers.forEach(n => uniqueNumbers.add(n));
                            if (set.crossPoint && set.crossPoint.numbers) {
                                set.crossPoint.numbers.forEach(n => uniqueNumbers.add(n));
                            }
                        });
                        if (uniqueNumbers.size > maxNumbers) {
                            maxNumbers = uniqueNumbers.size;
                        }
                    }
                });
                
                // Ìó§Îçî 1Ìñâ
                const header1 = ['', '', ''];
                for (let i = 0; i < 3; i++) {
                    header1.push(`${i + 1}Î≤àÏß∏ Ïßù`, '', '', '', '', '', '', '', '');
                }
                
                // BAÏó¥ÍπåÏßÄ Îπà Ïπ∏ Ï±ÑÏö∞Í∏∞ (BA = 53Î≤àÏß∏ Ïó¥, Ïù∏Îç±Ïä§ 52)
                while (header1.length < 52) {
                    header1.push('');
                }
                
                // Ïà´Ïûê (BAÏó¥)
                header1.push('Ïà´Ïûê');
                
                // 16Ïπ∏ ÎùÑÏö∞Í∏∞
                const oddsHeaderIndex = 52 + 16;
                while (header1.length < oddsHeaderIndex) {
                    header1.push('');
                }
                
                // Î∞∞ÎãπÌï©Í≥Ñ
                header1.push('Î∞∞ÎãπÌï©Í≥Ñ');
                
                // 16Ïπ∏ ÎùÑÏö∞Í∏∞
                const ratioHeaderIndex = oddsHeaderIndex + 16;
                while (header1.length < ratioHeaderIndex) {
                    header1.push('');
                }
                
                // ÎπÑÏ§ë(%)
                header1.push('ÎπÑÏ§ë(%)');
                
                // 16Ïπ∏ ÎùÑÏö∞Í∏∞
                const statsHeaderIndex = ratioHeaderIndex + 16;
                while (header1.length < statsHeaderIndex) {
                    header1.push('');
                }
                
                // Îπà Ïπ∏ 1Í∞ú
                header1.push('');
                
                // ÎπÑÏ§ë ÌÜµÍ≥Ñ Î∂ÑÏÑù (1Ïπ∏Ïî© ÎùÑÏö∞Í∏∞)
                header1.push('ÌèâÍ∑†');
                header1.push('');
                header1.push('ÌëúÏ§ÄÌé∏Ï∞®');
                header1.push('');
                header1.push('ÏµúÎåÄ-ÏµúÏÜåÏ∞®Ïù¥');
                
                ws_data.push(header1);
                
                // Ìó§Îçî 2Ìñâ
                const header2 = ['', '', 'ÌÖåÏä§Ìä∏ÌöåÏ∞®'];
                for (let i = 0; i < 3; i++) {
                    header2.push('1-1_Î≤àÌò∏', '1-2_Î≤àÌò∏', 'Î∞∞Îãπ', '2-1_Î≤àÌò∏', '2-2_Î≤àÌò∏', 'Î∞∞Îãπ', 'ÍµêÏ∞®Ï†ê-1_Î≤àÌò∏', 'ÍµêÏ∞®Ï†ê-2_Î≤àÌò∏', 'Î∞∞Îãπ');
                }
                
                // BAÏó¥ÍπåÏßÄ Îπà Ïπ∏ Ï±ÑÏö∞Í∏∞
                while (header2.length < 52) {
                    header2.push('');
                }
                
                // Ïà´ÏûêÎì§ (1, 2, 3, ...)
                for (let i = 1; i <= maxNumbers; i++) {
                    header2.push(i);
                }
                
                // 16Ïπ∏ ÎùÑÏö∞Í∏∞ ÌõÑ Î∞∞ÎãπÌï©Í≥Ñ
                while (header2.length < oddsHeaderIndex) {
                    header2.push('');
                }
                for (let i = 1; i <= maxNumbers; i++) {
                    header2.push(i);
                }
                
                // 16Ïπ∏ ÎùÑÏö∞Í∏∞ ÌõÑ ÎπÑÏ§ë
                while (header2.length < ratioHeaderIndex) {
                    header2.push('');
                }
                for (let i = 1; i <= maxNumbers; i++) {
                    header2.push(i);
                }
                
                ws_data.push(header2);
                
                // Îç∞Ïù¥ÌÑ∞ Ìñâ
                analysisHistory2.forEach((history, idx) => {
                    const row = ['', '', idx + 1];
                    
                    // ÍµêÏ∞®Ï†ê Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞
                    for (let i = 0; i < 3; i++) {
                        if (i < history.crossPointSets.length) {
                            const set = history.crossPointSets[i];
                            row.push(
                                set.first.numbers[0] || '',
                                set.first.numbers[1] || '',
                                set.first.odds || '',
                                set.second.numbers[0] || '',
                                set.second.numbers[1] || '',
                                set.second.odds || '',
                                set.crossPoint.odds ? (set.crossPoint.numbers[0] || '') : 'ÏóÜÏùå',
                                set.crossPoint.odds ? (set.crossPoint.numbers[1] || '') : '',
                                set.crossPoint.odds || 'ÏóÜÏùå'
                            );
                        } else {
                            row.push('', '', '', '', '', '', '', '', '');
                        }
                    }
                    
                    // BAÏó¥ÍπåÏßÄ Îπà Ïπ∏ Ï±ÑÏö∞Í∏∞
                    while (row.length < 52) {
                        row.push('');
                    }
                    
                    // Ïà´ÏûêÎ≥Ñ Î∞∞Îãπ Ìï©Í≥Ñ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
                    const numberSums = {};
                    const numberCounts = {};
                    history.crossPointSets.forEach(set => {
                        // first Ïßù
                        set.first.numbers.forEach(n => {
                            if (!numberSums[n]) {
                                numberSums[n] = 0;
                                numberCounts[n] = 0;
                            }
                        });
                        // second Ïßù
                        set.second.numbers.forEach(n => {
                            if (!numberSums[n]) {
                                numberSums[n] = 0;
                                numberCounts[n] = 0;
                            }
                        });
                        // crossPoint
                        if (set.crossPoint && set.crossPoint.numbers) {
                            set.crossPoint.numbers.forEach(n => {
                                if (!numberSums[n]) {
                                    numberSums[n] = 0;
                                    numberCounts[n] = 0;
                                }
                            });
                        }
                        
                        // Î∞∞Îãπ Ìï©ÏÇ∞ (Í∞Å Ï°∞Ìï©ÏóêÏÑú Ìï¥Îãπ Ïà´ÏûêÍ∞Ä Ìè¨Ìï®Îêú ÎßåÌÅº)
                        set.first.numbers.forEach(n => {
                            numberSums[n] += set.first.odds;
                            numberCounts[n]++;
                        });
                        set.second.numbers.forEach(n => {
                            numberSums[n] += set.second.odds;
                            numberCounts[n]++;
                        });
                        if (set.crossPoint && set.crossPoint.odds) {
                            set.crossPoint.numbers.forEach(n => {
                                numberSums[n] += set.crossPoint.odds;
                                numberCounts[n]++;
                            });
                        }
                    });
                    
                    // ÎπÑÏ§ë ÎÇÆÏùÄ ÏàúÏúºÎ°ú Ï†ïÎ†¨
                    const totalOdds = Object.values(numberSums).reduce((sum, val) => sum + val, 0);
                    const sortedNumbers = Object.keys(numberSums)
                        .map(n => parseInt(n))
                        .sort((a, b) => numberSums[a] - numberSums[b]);
                    
                    if (sortedNumbers.length > 0) {
                        // 1. Ïà´ÏûêÎì§
                        sortedNumbers.forEach((num) => {
                            row.push(num);
                        });
                        
                        // 16Ïπ∏ ÎùÑÏö∞Í∏∞
                        while (row.length < oddsHeaderIndex) {
                            row.push('');
                        }
                        
                        // 2. Î∞∞ÎãπÌï©Í≥ÑÎì§
                        sortedNumbers.forEach((num) => {
                            row.push(parseFloat(numberSums[num]).toFixed(1));
                        });
                        
                        // 16Ïπ∏ ÎùÑÏö∞Í∏∞
                        while (row.length < ratioHeaderIndex) {
                            row.push('');
                        }
                        
                        // 3. ÎπÑÏ§ëÎì§
                        sortedNumbers.forEach((num) => {
                            const ratio = (numberSums[num] / totalOdds * 100).toFixed(2);
                            row.push(ratio);
                        });
                        
                        // 16Ïπ∏ ÎùÑÏö∞Í∏∞
                        while (row.length < statsHeaderIndex) {
                            row.push('');
                        }
                        
                        // Îπà Ïπ∏ 1Í∞ú
                        row.push('');
                        
                        // 4. ÎπÑÏ§ë ÌÜµÍ≥Ñ Î∂ÑÏÑù
                        const oddsValues = sortedNumbers.map(num => numberSums[num]);
                        const avg = oddsValues.reduce((a, b) => a + b, 0) / oddsValues.length;
                        const variance = oddsValues.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / oddsValues.length;
                        const stdDev = Math.sqrt(variance);
                        const maxVal = Math.max(...oddsValues);
                        const minVal = Math.min(...oddsValues);
                        const diff = maxVal - minVal;
                        
                        row.push(avg.toFixed(2));
                        row.push(''); // 1Ïπ∏ ÎùÑÏö∞Í∏∞
                        row.push(stdDev.toFixed(2));
                        row.push(''); // 1Ïπ∏ ÎùÑÏö∞Í∏∞
                        row.push(diff.toFixed(2));
                    }
                    
                    ws_data.push(row);
                });
                
                // ÏõåÌÅ¨ÏãúÌä∏ ÏÉùÏÑ±
                const ws = XLSX.utils.aoa_to_sheet(ws_data);
                
                // Ïó¥ ÎÑàÎπÑ ÏÑ§Ï†ï
                ws['!cols'] = [
                    { wch: 5 }, { wch: 5 }, { wch: 12 },
                    { wch: 10 }, { wch: 10 }, { wch: 10 },
                    { wch: 10 }, { wch: 10 }, { wch: 10 },
                    { wch: 12 }, { wch: 12 }, { wch: 10 },
                    { wch: 10 }, { wch: 10 }, { wch: 10 },
                    { wch: 10 }, { wch: 10 }, { wch: 10 },
                    { wch: 12 }, { wch: 12 }, { wch: 10 },
                    { wch: 10 }, { wch: 10 }, { wch: 10 },
                    { wch: 10 }, { wch: 10 }, { wch: 10 },
                    { wch: 12 }, { wch: 12 }, { wch: 10 }
                ];
                
                // ÏõåÌÅ¨Î∂Å ÏÉùÏÑ±
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'Sheet1');
                
                // ÌååÏùº Îã§Ïö¥Î°úÎìú
                XLSX.writeFile(wb, fileName);
                
                alert(`${analysisHistory2.length}Í∞ú ÌöåÏ∞®Í∞Ä "${fileName}" ÌååÏùºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§.`);
            } catch (error) {
                console.error('Excel export error:', error);
                alert('ÏóëÏÖÄ Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
            }
        }
    


        // Ïä§ÌÅ¨Î°§ Ìï®Ïàò
        function scrollToSectionA() {
            // ÍµêÏ∞®Ï†êÎ∂ÑÏÑù1Î°ú Ïù¥Îèô (index1111Ïùò Ï≤´ Î≤àÏß∏ Î∂ÑÏÑù Î∞ïÏä§)
            const section = document.querySelector('.analysis-box');
            if (section) {
                const yOffset = -20;
                const y = section.getBoundingClientRect().top + window.pageYOffset + yOffset;
                window.scrollTo({
                    top: y,
                    behavior: 'smooth'
                });
            }
        }

        function scrollToSectionB() {
            // 1-10Ï§Ñ Î∂ÑÏÑùÏúºÎ°ú Ïù¥Îèô
            const titles = document.querySelectorAll('.table-title');
            let target = null;
            titles.forEach(title => {
                if (title.textContent.includes('1-10')) {
                    target = title.parentElement; // table-container
                }
            });
            if (target) {
                const yOffset = -20;
                const y = target.getBoundingClientRect().top + window.pageYOffset + yOffset;
                window.scrollTo({
                    top: y,
                    behavior: 'smooth'
                });
            }
        }

        function scrollToSectionC() {
            // Ï†ÑÏ≤¥ Ïà´ÏûêÎ≥Ñ Î∞∞Îãπ Ìï©Í≥ÑÎ°ú Ïù¥Îèô (index2222Ïùò Ï≤´ Î≤àÏß∏ ÏÑπÏÖò)
            const section = document.getElementById('results2');
            if (section) {
                const yOffset = -20;
                const y = section.getBoundingClientRect().top + window.pageYOffset + yOffset;
                window.scrollTo({
                    top: y,
                    behavior: 'smooth'
                });
            }
        }

        function scrollToSectionD() {
            // Í∞Å Ïà´ÏûêÎ≥Ñ Ï≤´ Î≤àÏß∏ Ï°∞Ìï©ÏúºÎ°ú Ïù¥Îèô
            const headers = document.querySelectorAll('.number-header');
            let target = null;
            headers.forEach(header => {
                if (header.textContent.includes('Í∞Å Ïà´ÏûêÎ≥Ñ Ï≤´ Î≤àÏß∏ Ï°∞Ìï©')) {
                    target = header;
                }
            });
            if (target) {
                const yOffset = -20;
                const y = target.parentElement.getBoundingClientRect().top + window.pageYOffset + yOffset;
                window.scrollTo({
                    top: y,
                    behavior: 'smooth'
                });
            }
        }

        // ========== Ïä§ÌÅ¨Î¶ΩÌä∏ ÎÅù ========== 
        </script>
</body>
</html>